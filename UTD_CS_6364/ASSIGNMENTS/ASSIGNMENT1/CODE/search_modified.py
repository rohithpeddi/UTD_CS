from utils import *
from search import *
import math


"""
UNIFORM COST SEARCH STRATEGY
"""

def uniform_cost_search_modified(problem, g):
    g = memoize(g, 'g')
    node = Node(problem.initial)
    frontier = PriorityQueue('min', g)
    frontier.append(node)
    explored = set()
    counter = 0
    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            return node
        explored.add(node.state)
        children = set()
        for child in node.expand(problem):
            children.add((child.state, g(child)))
            if child.state not in explored and child not in frontier:
                frontier.append(child)
            elif child in frontier:
                if g(child) < frontier[child]:
                    del frontier[child]
                    frontier.append(child)
        counter += 1
        print_strategy_items('UCS', counter, node, g, explored, frontier, children)
    return None


def print_strategy_items(strategy, counter, node, f, explored, frontier, children):
    print('--------------------------------------------------------------------------------')
    print(strategy + ' STEP : ' + str(counter))
    print('1. Current Node : ' + str(node.state))
    print('2. Evaluation function : ' + str(f(node)))
    print('3. Frontier : ')
    frontier.print_items()
    print('4. Explored : ')
    print(list({k: 1 for k in explored}))
    print('5. Children : ')
    print(list({k: 1 for k in children}))


"""
ITERATIVE DEEPENING SEARCH STRATEGY
"""

def depth_limited_search_modified(problem, limit=50):
    frontier = [(Node(problem.initial))]  # Stack
    counter = 0
    while frontier:
        node = frontier.pop()
        children = set()
        counter += 1
        if problem.goal_test(node.state):
            print_dls(limit, counter, node, frontier, children)
            return node
        elif node.path_cost == limit:
            print_dls(limit, counter, node, frontier, children)
            continue
        for child in node.expand(problem):
            children.add(child.state)
            if child not in frontier:
                frontier.append(child)
        print_dls(limit, counter, node, frontier, children)
    return 'cutoff'


def print_dls(depth, counter, node, frontier, children=set()):
    print('--------------------------------------------------------------------------------')
    print('Depth : ' + str(depth) + ', Step : ' + str(counter))
    print('1. Current Node : ' + str(node.state))
    print('2. Frontier : ')
    print("".join([str(x) for x in frontier]))
    print('3. Children : ')
    print(list({k: 1 for k in children})) if len(children) > 0 else print('[]')


def iterative_deepening_search_modified(problem):
    for depth in range(sys.maxsize):
        result = depth_limited_search_modified(problem, depth)
        if result != 'cutoff':
            return result


"""
HEURISTIC CONSISTENCY CHECK
"""

def best_first_graph_search_consistent_heuristic_check(problem, f, h, display=False):
    """Search the nodes with the lowest f scores first.
    You specify the function f(node) that you want to minimize; for example,
    if f is a heuristic estimate to the goal, then we have greedy best
    first search; if f is node.depth then we have breadth-first search.
    There is a subtlety: the line "f = memoize(f, 'f')" means that the f
    values will be cached on the nodes as they are computed. So after doing
    a best first search you can examine the f values of the path returned."""
    h = memoize(h, 'h')
    f = memoize(f, 'f')
    node = Node(problem.initial)
    frontier = PriorityQueue('min', f)
    frontier.append(node)
    explored = set()
    is_consistent = True
    while (frontier.__len__() > 0) and is_consistent:
        node = frontier.pop()
        """
        1. Here we comment out check for goal state
        2. A heuristic is consistent if for every node n and every successor n' of n generated by an action a, 
        the estimated cost of reaching the goal from n is no greater than the step cost of getting to n' 
        plus the estimated cost of reaching the goal from n'         
        3. h(parent) <= c(parent, action, child) + h(child)
        """
        # if problem.goal_test(node.state):
        #     if display:
        #         print(len(explored), "paths have been expanded and", len(frontier), "paths remain in the frontier")
        #     return node
        explored.add(node.state)
        for child in node.expand(problem):
            print('--------------------------------------------------------------------------------')
            print('Checking consistency for ')
            print('n : ' + str(node.state))
            print('n\' : ' + str(child.state))
            print('h(n) : ' + str(h(node)))
            print('h(n\') : ' + str(h(child)))
            print('h(n) - h(n\') : ' + str(h(node) - h(child)))
            print('c(n,a,n\') : ' + str(child.path_cost) + ' - ' + str(node.path_cost) + ' = ' + str(child.path_cost-node.path_cost))
            if h(node) > (child.path_cost - node.path_cost) + h(child):
                print('NOT CONSISTENT')
                return False
            else:
                print('ARC CONSISTENT')

            if child.state not in explored and child not in frontier:
                frontier.append(child)
            elif child in frontier:
                if f(child) < frontier[child]:
                    del frontier[child]
                    frontier.append(child)
    return True

def consistent_heuristic_check(problem, h=None, display=False):
    h = memoize(h or problem.h, 'h')
    return best_first_graph_search_consistent_heuristic_check(problem, lambda n: n.path_cost + h(n), lambda n: h(n), display)

"""
GREEDY BEST FIRST SEARCH STRATEGY
It requires the usage of a heuristic function.
We define an admissible heuristic h(M,C,B) = Max((3-M) + (3-C) - 1, 0)
"""


def best_first_search_modified(strategy, problem, f, display=False):
    f = memoize(f, 'f')
    node = Node(problem.initial)
    frontier = PriorityQueue('min', f)
    frontier.append(node)
    explored = set()
    counter = 0
    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            if display:
                print(len(explored), "paths have been expanded and", len(frontier), "paths remain in the frontier")
            return node
        explored.add(node.state)
        children = set()
        for child in node.expand(problem):
            children.add((child.state, f(child)))
            if child.state not in explored and child not in frontier:
                frontier.append(child)
            elif child in frontier:
                if f(child) < frontier[child]:
                    del frontier[child]
                    frontier.append(child)
        counter += 1
        print_strategy_items(strategy, counter, node, f, explored, frontier, children)
    return None

def recursive_best_first_search_modified(problem, h=None):
    h = memoize(h or problem.h, 'h')
    node = Node(problem.initial)
    node.f = h(node)

    def RBFS(problem, node, flimit):
        if problem.goal_test(node.state):
            return node, 0  # (The second value is immaterial)
        successors = node.expand(problem)
        if len(successors) == 0:
            return None, np.inf
        for s in successors:
            s.f = max(s.path_cost + h(s), node.f)
        while True:
            # Order by lowest f value
            successors.sort(key=lambda x: x.f)
            best = successors[0]
            if best.f > flimit:
                print_rbfs(flimit, best, np.inf, node.state, node.parent.state)
                return None, best.f
            if len(successors) > 1:
                alternative = successors[1].f
            else:
                alternative = np.inf
            print_rbfs(flimit, best, alternative, node.state, best.state)
            result, best.f = RBFS(problem, best, min(flimit, alternative))
            if result is not None:
                return result, best.f

    result, bestf = RBFS(problem, node, np.inf)
    return result

def print_rbfs(flimit, best, alternative, current_node, next_node):
    print('------------------------------------------------------------')
    print('1. f_limit: ' + str(flimit))
    print('2. best: ' + str(best.f))
    print('3. alternative: ' + str(alternative))
    print('4. current node: ' + str(current_node))
    print('5. next node: ' + str(next_node))
    print('------------------------------------------------------------')
    return
