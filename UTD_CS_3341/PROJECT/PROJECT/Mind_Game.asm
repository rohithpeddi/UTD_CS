STARTGAME:
.data
list: 		.word 1,2,4,8,16,32
#nums: 		.word 32,16,8,4,2,1
result:	.word 200
		
.text
	.globl generator	

# ------------------------------- WELCOME SECTION ---------------------------------------
Register_Reset: #Resetting all used registers, so if the user wants to play the game again, it runs successfully
	li $v0,0
	li $v1,0
	li $a0,0
	li $a1,0
	li $a2,0
	li $a3,0
	li $t0,0
	li $t1,0
	li $t2,0
	li $t3,0
	li $t4,0
	li $t5,0
	li $t6,0
	li $t7,0
	li $t8,0
	
	li $v0, 61 # syscall to display the welcome message and ask user whether he wants to play the game (Yes/No)
	syscall
	
	bne $a0,0,EXITGAME # if user selects NO, the game will exit
	
	li $s0,6 #using saved register 0 to store the number of cards to be generated
	li $t0,-1 #storing the initiator default value 
     	addi $sp, $sp, -1000 # make room to save the 6 positions and temporaries
     	la $t3,($sp)    #saving the new stack pointer location
 
Initiate:
     addi $t2,$t2,1 #using this as counter to initiate each of 6 positions with -1
     sw $t0,($sp) #saving -1 in each position
     addi $sp,$sp,4 #moving stack pointer by 1 word each time
     slt $t4,$t2,$s0 #checking whether all 6 positions are initiated or not
     bne $t4,$0,Initiate #to loop over the 6 positions 
RandNumGen:
    la $sp,($t3) #restoring $sp value 
    li $a1, 100  #Here you set $a1 to the max bound.
    li $v0, 42  #generates the random number.
    syscall
    divu $a0,$s0 #dividing the random number generated by 6 to get the remainder (0-5)
    mfhi $t2 #saving the random remainder in $t2
CheckingPosition:  
    sll $t2,$t2,2 #multiplying the remainder by 4 to check the word location of the number 
    add $sp,$sp,$t2 #moving stack pointer to the specific location 
    lw $t4,($sp) #checking the position value of that location
    bne $t4,$t0,RandNumGen #if the position value is still -1 , it will go ahead and call the Card generator with that random remainder as argument, else it will recall random number generation
    addi $t1,$t1,1 #if the random number is accepted, increasing the counter by 1 for each call
PreservingTemporaries:
    srl $t2,$t2,2 #restoring the remainder value by dividing by 4
    la $sp,($t3) #resetting $sp to the intended start location
    sw $t1, 24($sp) #saving the counter value stored in $t1 
    sw $t2, 28($sp) #saving the random generated number 
    addi $sp,$sp,1000 #restoring $sp value 
    move $a0,$t2 #copying the random number to $a0 to save as argument
    jal generator #calling the card generator function ,which will return back 0 or 1 for the position $t2
    
 RestoringTemporaries:
    addi $sp,$sp,-1000 #taking stack pointer back to the location where 6 positions are stored
    la $t3,($sp)    #saving the new stack pointer location
    li $t0,-1 #reinitiating $t0 to check default value
    lw $t1,24($sp) #restoring the counter value to check the number of cards already shown
    lw $t2,28($sp) #restoring the random number sent to the Card Generator function
SavingUserChoice:
    sll $t2,$t2,2 #multiplying the remainder by 4 to check the word location of the number
    add $sp,$sp,$t2 #moving stack pointer to the specific location
    sw $a1,($sp) #saving user choice at that location (provided that CardGenerator subroutine sends the argument back in $a1

   slt $t4,$t1,$s0 #checking if all 6 cards are generated
   #slti $t4,$t1,1 #checking if all 6 cards are generated - delete this later uncomment prev line
    bne $t4,$0,RandNumGen #if not recalling Randum Number Generator
    j resultgen
 #   jal ResultGenerator #else calling result generator
 
 
# ------------------------------------------- NUMBER GENERATION SECTION -------------------------------------------------
 
generator: 	move $t0,$a0		#Gets the argument from the caller	 		 	
	 		move $a1, $a0
	 		
	 		la $s7, list	 	
	 		sll $t0, $t0, 2			#Multyplying the given number by 4
	 		add $t1, $s7, $t0		#Adding the shift address amount to the base address of the list
	 		lw  $s7, ($t1) 			#Fetch the result in the current position of the list
	 		
	 		la $s1, result			#Fetch the address to store the result array
	 		move $s6, $s1
	 		add $s3, $s7, $zero		#current value in $s3, current counter in $s2
	 		
Loop: 		slti $t8, $s3, 64 
			bne $t8, 1, exit			#Exit the loop if the value exceeds 64
			
			sw $s3, ($s1)			#Store the current value
			addi $s1, $s1, 4		#Increment the current pointer of address to store the result
			addi $s2, $s2, 1		#Increment the counter
			addi $s3, $s3, 1		#Increment the current value
			
			beq $s2, $s7, newStart	#Add this branch to indicate a jump in the values
			j 	Loop				#Perform the loop
			
			
newStart: 	add $s3, $s3, $s7		#Slide the start to a new point
			add $s2, $zero, $zero	#Make the current counter to zero
			j	Loop 
			
		
exit:	
	move $a0, $s6
	li $v0, 60
	syscall
	
	li $t0, 1
	slt $a1, $a0, $t0	
	jr $ra


# ---------------------------------------------------- RESULT SECTION ----------------------------------------------

resultgen:
li $t0,1
move $t4,$t3
la $t5,list
ResultLoop:
lw $t6,($t4)
lw $t7,($t5)
mul $t7,$t7,$t6
add $s5,$s5,$t7
addi $t0,$t0,1
addi $t4,$t4,4
addi $t5,$t5,4
slti $t8,$t0,7
beq $t8,$0,show
j ResultLoop
show:
move $a0,$s5
li $v0,62
syscall
beq $a0,$0,STARTGAME
EXITGAME:
li $v0, 10 
syscall

